// Copyright (c) 2016 Janoš Guljaš <janos@resenje.org>
// All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package distance

import (
	"bytes"
	"crypto/rand"
	"testing"
)

func TestHamming(t *testing.T) {
	var dist uint64

	for _, tc := range [][]byte{
		{0},
		{1},
		{2},
		{1, 1},
		{1, 2},
		{1, 1, 1},
		{1, 1, 1, 0, 0, 0x80, 2},
		{0x12, 0x34, 0x56, 0x78, 0x9A, 0xBC, 0xDE, 0xF0},
		{0x12, 0x34, 0x56, 0x78, 0x9A, 0xBC, 0xDE, 0xF0, 0, 1},
		{0x12, 0x34, 0x56, 0x78, 0x9A, 0xBC, 0xDE, 0xF0, 0, 1, 2},
		{0x12, 0x34, 0x56, 0x78, 0x9A, 0xBC, 0xDE, 0xF0, 0, 1, 2, 3},
		{0x12, 0x34, 0x56, 0x78, 0x9A, 0xBC, 0xDE, 0xF0, 0, 1, 2, 3, 4},
		{0x12, 0x34, 0x56, 0x78, 0x9A, 0xBC, 0xDE, 0xF0, 0, 1, 2, 3, 4, 5},
		{0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF},
		{0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x01},
		{0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF},
	} {
		dist = Hamming(tc, tc)
		if dist != 0 {
			t.Errorf("%v: expected 0 got %d", tc, dist)
		}
	}

	for _, tc := range []struct {
		dist   uint64
		value1 []byte
		value2 []byte
	}{
		{1, []byte{0}, []byte{1}},
		{0, []byte{0}, []byte{0, 1}},
		{64, []byte{0, 0, 0, 0, 0, 0, 0, 0}, []byte{0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF}},
		{56, []byte{0, 0, 0, 0, 0, 0, 0}, []byte{0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF}},
		{48, []byte{0, 0, 0, 0, 0, 0}, []byte{0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF}},
		{40, []byte{0, 0, 0, 0, 0}, []byte{0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF}},
		{32, []byte{0, 0, 0, 0}, []byte{0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF}},
		{24, []byte{0, 0, 0}, []byte{0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF}},
		{16, []byte{0, 0}, []byte{0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF}},
		{8, []byte{0}, []byte{0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF}},
		{0, []byte{}, []byte{0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF}},
		{32, []byte{0x12, 0x34, 0x56, 0x78, 0x9A, 0xBC, 0xDE, 0xF0}, []byte{0, 0, 0, 0, 0, 0, 0, 0}},
		{64, []byte{0x12, 0x34, 0x56, 0x78, 0x9A, 0xBC, 0xDE, 0xF0, 0, 0, 0, 0, 0, 0, 0, 0}, []byte{0, 0, 0, 0, 0, 0, 0, 0, 0x12, 0x34, 0x56, 0x78, 0x9A, 0xBC, 0xDE, 0xF0}},
	} {
		dist = Hamming(tc.value1, tc.value2)
		if dist != tc.dist {
			t.Errorf("%v %v: expected %d got %d", tc.value1, tc.value2, tc.dist, dist)
		}
		dist = Hamming(tc.value2, tc.value1)
		if dist != tc.dist {
			t.Errorf("%v %v: expected %d got %d", tc.value2, tc.value1, tc.dist, dist)
		}
	}
}

func TestXOR(t *testing.T) {
	var xor, exor []byte

	for _, tc := range [][]byte{
		{0},
		{1},
		{2},
		{1, 1},
		{1, 2},
		{1, 1, 1},
		{1, 1, 1, 0, 0, 0x80, 2},
		{0x12, 0x34, 0x56, 0x78, 0x9A, 0xBC, 0xDE, 0xF0},
		{0x12, 0x34, 0x56, 0x78, 0x9A, 0xBC, 0xDE, 0xF0, 0, 1},
		{0x12, 0x34, 0x56, 0x78, 0x9A, 0xBC, 0xDE, 0xF0, 0, 1, 2},
		{0x12, 0x34, 0x56, 0x78, 0x9A, 0xBC, 0xDE, 0xF0, 0, 1, 2, 3},
		{0x12, 0x34, 0x56, 0x78, 0x9A, 0xBC, 0xDE, 0xF0, 0, 1, 2, 3, 4},
		{0x12, 0x34, 0x56, 0x78, 0x9A, 0xBC, 0xDE, 0xF0, 0, 1, 2, 3, 4, 5},
		{0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF},
		{0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x01},
		{0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF},
	} {
		xor = XOR(tc, tc)
		exor = make([]byte, len(tc))
		if !bytes.Equal(xor, exor) {
			t.Errorf("%v: expected %v got %v", tc, exor, xor)
		}
	}

	for _, tc := range []struct {
		xor    []byte
		value1 []byte
		value2 []byte
	}{
		{[]byte{1}, []byte{0}, []byte{1}},
		{[]byte{0}, []byte{0}, []byte{0}},
		{[]byte{1}, []byte{0, 1}, []byte{1}},
		{[]byte{0}, []byte{0}, []byte{0, 1}},
		{[]byte{0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF}, []byte{0, 0, 0, 0, 0, 0, 0, 0}, []byte{0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF}},
		{[]byte{0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF}, []byte{0, 0, 0, 0, 0, 0, 0}, []byte{0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF}},
		{[]byte{0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF}, []byte{0, 0, 0, 0, 0, 0}, []byte{0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF}},
		{[]byte{0xFF, 0xFF, 0xFF, 0xFF, 0xFF}, []byte{0, 0, 0, 0, 0}, []byte{0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF}},
		{[]byte{0xFF, 0xFF, 0xFF, 0xFF}, []byte{0, 0, 0, 0}, []byte{0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF}},
		{[]byte{0xFF, 0xFF, 0xFF}, []byte{0, 0, 0}, []byte{0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF}},
		{[]byte{0xFF, 0xFF}, []byte{0, 0}, []byte{0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF}},
		{[]byte{0xFF}, []byte{0}, []byte{0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF}},
		{[]byte{}, []byte{}, []byte{0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF}},
		{[]byte{0x12, 0x34, 0x56, 0x78, 0x9A, 0xBC, 0xDE, 0xF0}, []byte{0x12, 0x34, 0x56, 0x78, 0x9A, 0xBC, 0xDE, 0xF0}, []byte{0, 0, 0, 0, 0, 0, 0, 0}},
		{[]byte{0x12, 0x34, 0x56, 0x78, 0x9A, 0xBC, 0xDE, 0xF0, 0x12, 0x34, 0x56, 0x78, 0x9A, 0xBC, 0xDE, 0xF0}, []byte{0x12, 0x34, 0x56, 0x78, 0x9A, 0xBC, 0xDE, 0xF0, 0, 0, 0, 0, 0, 0, 0, 0}, []byte{0, 0, 0, 0, 0, 0, 0, 0, 0x12, 0x34, 0x56, 0x78, 0x9A, 0xBC, 0xDE, 0xF0}},
	} {
		xor = XOR(tc.value1, tc.value2)
		if !bytes.Equal(xor, tc.xor) {
			t.Errorf("%v %v: expected %d got %d", tc.value1, tc.value2, tc.xor, xor)
		}
	}
}

func TestPopCount(t *testing.T) {
	for _, tc := range []struct {
		count uint64
		value []byte
	}{
		{0, []byte{0}},
		{1, []byte{1}},
		{1, []byte{2}},
		{2, []byte{1, 1}},
		{2, []byte{1, 2}},
		{3, []byte{1, 1, 1}},
		{5, []byte{1, 1, 1, 0, 0, 0x80, 2}},
		{32, []byte{0x12, 0x34, 0x56, 0x78, 0x9A, 0xBC, 0xDE, 0xF0}},
		{33, []byte{0x12, 0x34, 0x56, 0x78, 0x9A, 0xBC, 0xDE, 0xF0, 0, 1}},
		{34, []byte{0x12, 0x34, 0x56, 0x78, 0x9A, 0xBC, 0xDE, 0xF0, 0, 1, 2}},
		{36, []byte{0x12, 0x34, 0x56, 0x78, 0x9A, 0xBC, 0xDE, 0xF0, 0, 1, 2, 3}},
		{37, []byte{0x12, 0x34, 0x56, 0x78, 0x9A, 0xBC, 0xDE, 0xF0, 0, 1, 2, 3, 4}},
		{39, []byte{0x12, 0x34, 0x56, 0x78, 0x9A, 0xBC, 0xDE, 0xF0, 0, 1, 2, 3, 4, 5}},
		{64, []byte{0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF}},
		{65, []byte{0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x01}},
		{72, []byte{0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF}},
	} {
		count := PopCount(tc.value)
		if count != tc.count {
			t.Errorf("%v: expected %d got %d", tc.value, tc.count, count)
		}
	}
}

func TestPopCountUint64(t *testing.T) {
	for _, tc := range []struct {
		count uint64
		value uint64
	}{
		{0, 0},
		{1, 1},
		{1, 2},
		{2, 3},
		{1, 0x8000000000000000},
		{2, 0x8000000000000001},
		{4, 0xF0},
		{7, 0xFE},
		{32, 0x123456789ABCDEF},
		{64, 0xFFFFFFFFFFFFFFFF},
	} {
		count := PopCountUint64(tc.value)
		if count != tc.count {
			t.Errorf("%v: expected %d got %d", tc.value, tc.count, count)
		}
	}
}

var result uint64

func BenchmarkPopCountUint64(b *testing.B) {
	var c uint64
	for i := 0; i < b.N; i++ {
		c = PopCountUint64(0x123456789ABCDEF)
	}
	result = c
}

func BenchmarkPopCount8Bytes(b *testing.B) {
	b.StopTimer()
	v := make([]byte, 8)
	if _, err := rand.Read(v); err != nil {
		b.Fatalf("rand.Read: %s", err)
	}
	var c uint64
	b.StartTimer()
	for i := 0; i < b.N; i++ {
		c = PopCount(v)
	}
	result = c
}

var xorResult []byte

func BenchmarkXOR8Bytes(b *testing.B) {
	b.StopTimer()
	v1 := make([]byte, 8)
	if _, err := rand.Read(v1); err != nil {
		b.Fatalf("rand.Read: %s", err)
	}
	v2 := make([]byte, 8)
	if _, err := rand.Read(v2); err != nil {
		b.Fatalf("rand.Read: %s", err)
	}
	b.StartTimer()
	var r []byte
	for i := 0; i < b.N; i++ {
		r = XOR(v1, v2)
	}
	xorResult = r
}

func BenchmarkHamming1Byte(b *testing.B) {
	benchmarkHammingBytes(b, 1)
}
func BenchmarkHamming8Bytes(b *testing.B) {
	benchmarkHammingBytes(b, 8)
}

func BenchmarkHamming16Bytes(b *testing.B) {
	benchmarkHammingBytes(b, 16)
}

func BenchmarkHamming32Bytes(b *testing.B) {
	benchmarkHammingBytes(b, 32)
}
func BenchmarkHamming33Bytes(b *testing.B) {
	benchmarkHammingBytes(b, 33)
}

func BenchmarkHamming64Bytes(b *testing.B) {
	benchmarkHammingBytes(b, 64)
}

func BenchmarkHamming128Bytes(b *testing.B) {
	benchmarkHammingBytes(b, 128)
}

func BenchmarkHamming1KBytes(b *testing.B) {
	benchmarkHammingBytes(b, 1024)
}

func BenchmarkHamming10KBytes(b *testing.B) {
	benchmarkHammingBytes(b, 10*1024)
}

func BenchmarkHamming1MByte(b *testing.B) {
	benchmarkHammingBytes(b, 1024*1024)
}

func benchmarkHammingBytes(b *testing.B, length int) {
	b.StopTimer()
	v1 := make([]byte, length)
	if _, err := rand.Read(v1); err != nil {
		b.Fatalf("rand.Read: %s", err)
	}
	v2 := make([]byte, length)
	if _, err := rand.Read(v2); err != nil {
		b.Fatalf("rand.Read: %s", err)
	}
	b.StartTimer()
	var c uint64
	for i := 0; i < b.N; i++ {
		c = Hamming(v1, v2)
	}
	result = c
}
